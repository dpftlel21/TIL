# 1. 객체와 배열

### - 원시값의 메서드

|                                      원시값                                      |                                                           객체                                                            |
| :------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------: |
|                                    원시형 값                                     |                                                 프로퍼티에 다양한 값 저장                                                 |
| 문자(string), 숫자(number), bigint, 불린(boolean), 심볼(symbol), null, undefined | `{name : "John", age : 30}`와 같이 `대괄호 {}`를 사용해 만들며,자바스크립트에는 여러 종류의 객체 존재, 함수도 객체의 일종 |
|                                  빠르고 가벼움                                   |                            함수를 프로퍼티로 저장 O but, 자원 많이 소모, 무겁고 추가 자원 사용                            |

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지합니다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용합니다.
3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만들어 줍니다. 이 객체는 곧 삭제됩니다.

   - "래퍼 객체"는 원시 타입에 따라 종류가 다양합니다. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, String,Number,Boolean, Symbol라고 부릅니다. 래퍼 객체 마다 제공하는 메서드 역시 다릅니다.

### 😱 String/Number/Boolean를 생성자로 쓰지 맙시다!

Java 등의 몇몇 언어에선 new Number(1) 또는 new Boolean(false)와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있습니다.

자바스크립트에서도 하위 호환성을 위해 이 기능을 남겨 두었는데, 이런 식으로 래퍼 객체를 만드는 건 추천하지 않습니다. 몇몇 상황에서 혼동을 불러일으키기 때문입니다.

```js
alert(typeof 0); // "number"

alert(typeof new Number(0)); // "object"!
```

객체는 논리 평가 시 항상 참을 반환하며 아래 `alert`는 무조건 열리게 됩니다.

```js
let zero = new Number(0);

if (zero) {
  // 변수 zero는 객체이므로, 조건문이 참이 됩니다.
  alert("그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!");
}
```

### 😱 null/undefined는 메서드가 없습니다.

특수 자료형인 null과 undefined의 원시값(null/undefined)은 위와 같은 법칙을 따르지 않습니다. 이 자료형과 연관되는 "래퍼 객체"도 없고, 메서드도 제공하지 않습니다. 어떤 의미에서는 두 자료형이 "가장 원시적"이라 할 수 있을 것 같습니다.

두 자료형에 속한 값의 프로퍼티에 접근하려 하면 에러가 발생합니다.

```js
alert(null.test); // 에러
```

---

## - 숫자형

1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 `IEEE-754`에 저장됩니다.

2. 임의의 길이를 가진 정수는 `BigInt 숫자`로 나타낼 수 있습니다. 일반적인 숫자는 253이상이거나 -253이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌습니다.

### ✔️ 숫자를 입력하는 다양한 방법

```js
let billion = 1000000000;

let billion = 1e9; // 10억, 1과 9개의 0
alert(6.2e9); // 62억
```

0을 많이 사용하여 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에, 10억(billion)을 나타낼 땐 `1bn`, 62억을 나타낼 땐 `6.2bn`으로 나타냅니다.

또한 숫자 옆에 `e`를 붙이고 0의 개수를 옆에 적어 나타낼 수도 있습니다.

```js
1e3 = 1 * 1000 //  e 오른쪽에 있는 수만큼의 10의 거듭제곱
1.23e6 = 1.23 * 1000000 //  e 오른쪽에 있는 수만큼의 10의 거듭제곱

let ms = 0.000001; // 1마이크로초(백만 분의 1초)
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

### ✔️ 16진수, 2진수, 8진수

16진수는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰입니다. 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하겠죠. 16진수는 0x를 사용해 표현할 수 있습니다.

```js
alert(0xff); // 255
```

2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b와 0o를 사용해 간단히 나타낼 수 있습니다.

```js
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, 진법은 다르지만, a와 b는 같은 수임
```

### ✔️ `toString(base)`

`num.toString(base)` 메서드는 base진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환합니다.

```js
let num = 255;

alert(num.toString(16)); // ff
alert(num.toString(2)); // 11111111
```

base는 2에서 36까지 쓸 수 있는데, 기본값은 10입니다.

`base=16` – 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 0부터 9, 10 이상의 수는 A부터 F를 사용하여 나타냅니다.

`base=2` – 비트 연산 디버깅에 주로 쓰입니다. 숫자는 0 또는 1이 될 수 있습니다.

`base=36` – 사용할 수 있는 base 중 최댓값으로, 0..9와 A..Z를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는 데 사용됩니다. 36 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다.

### ✔️ 부정확한 계산

숫자는 내부적으로 64비트 형식 `IEEE-754`으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다. 숫자가 너무 커지면 64비트 공간이 넘쳐서 `Infinity`로 처리됩니다.

```js
alert(1e500); // Infinity
```

#### 😱 정밀도 손실

```js
alert(0.1 + 0.2); // 0.30000000000000004
```

숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.

0.1은 1을 10으로 나눈 수인 1/10입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. 1/10과 1/3을 비교해보면 1/3은 무한 소수 0.33333(3)이 됩니다.

10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 `정확하게` 저장하는 방법은 없습니다. 따라서 `정밀도 손실`이 발생하게 됩니다.

이 때 `toFixed(n)`메서드를 사용하여 어림수를 만듭니다. 단, `toFixed(n)`는 항상 문자열을 반환하므로 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 됩니다.

```js
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // 0.30 , sum 앞에 +(단항 덧셈 연산자)
```

### ✔️ `isNaN`, `isFinite`

1. `isNaN(value)` – 인수를 숫자로 변환한 다음 NaN인지 테스트

   ` NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특합니다.

```js
alert(isNaN(NaN)); // true
alert(isNaN("str")); // true
```

2. `isFinite(value)` – 인수를 숫자로 변환하고 변환한 숫자가` NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 true를 반환합니다.

   `isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 합니다.

   빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급됩니다.

### ✔️ `parseInt`, `parseFloat`

두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환하죠. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환합니다.

```js
alert(parseInt("100px")); // 100
alert(parseFloat("10.1em")); // 10.1

alert(parseInt("11.3")); // 11, 정수 부분만 반환됩니다.
alert(parseFloat("14.3.4")); // 14.3, 두 번째 점에서 숫자 읽기를 멈춥니다.
```

---

## - 문자열

자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없습니다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장됩니다.

자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상` `UTF-16`` 형식을 따릅니다.

### ✔️ 따옴표 "", ``, ''

`''`와 `""`의 기능상 차이는 없으나 `은 특별한 기능이 존재합니다. 표현식을`${…}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있는데 이런 방식이 템플릿 리터럴(template literal) 입니다.

```js
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

### ✔️ 특수 기호

|    문자     |                                                              설명                                                              |
| :---------: | :----------------------------------------------------------------------------------------------------------------------------: |
|     \n      |                                                             줄바꿈                                                             |
|     \r      |                              캐리지 리턴, 캐리지 리턴과 줄 바꿈 특수문자를 조합해 줄을 바꿉니다.                               |
|   \' , \"   |                                                             따옴표                                                             |
|    `\\`     |                                                            역슬래시                                                            |
|     \t      |                                                               탭                                                               |
| \b , \f, \v |                                                  백스페이스, 폼 피드, 세로 탭                                                  |
|    \xXX     |                                       16진수 유니코드 `XX`로 표현한 유니코드 글자입니다.                                       |
|    \uXXX    | `UTF-16` 인코딩 규칙을 사용하는 16진수 코드 XXXX로 표현한 유니코드 기호입니다. XXXX는 반드시 네 개의 16진수로 구성되어야 합니다. |

- 모든 특수 문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character) \로 시작합니다.

### ✔️ 특정 글자에 접근

문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면 `[pos]`같이 대괄호를 이용하거나 `str.charAt(pos)`라는 메서드를 호출하면 됩니다. 위치는 0부터 시작합니다.

```js
let str = `Hellom, Inwoo`;

// 첫 번째 글자
alert(str[0]); // H
alert(str.charAt(0)); // H

// 마지막 글자
alert(str[str.length - 1]); // o
```

### ✔️ 문자열의 불변성

문자열은 수정할 수 없습니다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생합니다.

따라서 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 됩니다.

```js
let str = "Hi";

str = "h" + str[1]; // 문자열 전체 교체

alert(str); //hi
```

### ✔️ 부분 문자열 찾기

> - toLowerCase() : 문자열을 소문자로 변경합니다.
> - toUpperCase() : 문자열을 대문자로 변경합니다.
> - concat() : 문자열 연결 연산자 +처럼 문자열을 이어 붙일 수 있습니다.
> - slice() : 문자열의 일부를 자를 수 있습니다.

- indexOf() : 문자열 내에 특정 문자나 문자가 몇 번째 위치하는지 확인합니다.

  - 만약 찾는 문자가 2개 이상일 경우, 가장 앞에 있는 문자의 인덱스를 조회합니다.
  - 포함되어 있지 않으면 -1을 반환합니다.

- includes() : 문자열 내에 특정 문자나 문자가 포함되어 있는지 확인합니다.
  - 있으면 true, 없으면 false를 반환합니다.

`includes`, `startsWith`, `endsWith`

1. `str.includes(substr, pos)`는 str에 부분 문자열 substr이 있는지에 따라 true나 false를 반환합니다.

```js
alert("Hello! welcome js world!".includes("Hello")); // true

alert("Hello".includes("Bye")); // false
```

2. 메서드 `str.startsWith`와 `str.endsWith`는 메서드 이름 그대로 문자열 str이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있습니다.

```js
alert("Hello! welcome js world!".startsWith("Hel")); // true, "Hello"는 "Hel"로 시작

lert("Hello! welcome js world!".endWith("llo")); // true, "Hello"는 "llo"로 끝남
```

### ✔️ 부분 문자열 추출

`substring`, `substr`, `slice` 이렇게 3가지가 있습니다.

- `str.slice(start [, end])`

  문자열의 start부터 end까지(end는 미포함)를 반환합니다.

  ```js
  let str = "gentleman";
  alert(str.slice(0, 5)); // 'gentl', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함 x)
  alert(str.slice(0, 1)); // 'g', 0번째부터 1번째 위치까지(1번째 위치의 자는 포함 x)
  ```

  두 번째 인수가 생략된 경우, 명시한 위치부터 끝까지 반환합니다.

  ```js
  let str = "gentleman";
  alert(str.slice(2)); // ntleman , 2번 째 부터 끝까지
  ```

  `start`, `end`는 음수가 될 수 있으며 음수를 넘기면 문자열 끝에서부터 카운팅을 시작합니다.

  ```js
  let str = "gentleman";

  // 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
  alert(str.slice(-4, -1)); // ema
  ```

- `str.substring(start [, end])`

  `start`와 `end` 사이에 있는 문자열을 반환하지만 `substring`은 `slice`와 아주 유사하지만 `start`가 `end`보다 커도 괜찮고, `slice`는 빈 문자열을 반환하는데 있어서 차이가 있습니다.

  ```js
  let str = "gentleman";

  // 동일한 부분 문자열을 반환합니다.
  alert( str.substring(2, 6) ); // "ntle"
  alert( str.substring(6, 2) ); // "ntle"
  ```

  `substring`은 음수 인수를 허용하지 않습니다. 음수는 0으로 처리됩니다.

* `str.substr(start [, length])`

  `start`에서부터 시작해 length 개의 글자를 반환하며, `substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서 `substring`과 `slice`와 차이가 있습니다.

  ```js
  let str = "gentleman";
  alert( str.substr(2, 4) ); // ntle, 두 번째부터 글자 네 개
  ```

  ```js
  let str = "gentleman";
  alert( str.substr(-4, 2) ); // em, 끝에서 네 번째 위치부터 글자 두 개
  ```


### ✔️ 문자열 비교

1. 소문자는 대문자보다 항상 큽니다.

    ```js
     alert("a" > "B" ); //true;
    ```

2. 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않습니다.


- 모든 문자열은 `UTF-16`을 사용해 인코딩되는데, `UTF-16`에선 모든 글자가 숫자 형식의 코드와 매칭됩니다.

  - 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드

  `str.codePointAt(pos)` : `pops` 위치한 글자의 코드를 반환합니다.

  ```js
   // 글자는 같지만 케이스는 다르므로 반환되는 코드가 다릅니다.
    alert( "z".codePointAt(0) ); // 122
    alert( "Z".codePointAt(0) ); // 90
  ```

  `String.fromCodePoint(code)` : 숫자 형식의 `code`에 대응하는 글자를 만들어줍니다.

  ```js
    alert( String.fromCodePoint(90) ); // Z
  ```

  `str.localeCompare(str2)`: str이 str2보다 작은지, 같은지, 큰지를 나타내주는 정수가 반환됩니다.

    - str이 str2보다 작으면 음수를 반환합니다.
    - str이 str2보다 크면 양수를 반환합니다.
    - str과 str2이 같으면 0을 반환합니다.