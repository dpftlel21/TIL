# 1. Stack & Queue

### ✔️ Stack ??

Stack은 쌓다, 쌓이다, 포개지다의 의미를 지니고 있고, 마치 접시를 쌓아 놓은 형태와 비슷한 자료구조이며, 데이터를 순서대로 쌓는 자료구조입니다. 

대표적인 사례로는 브라우저의 앞 및 뒤로가기 기능이 있습니다.


#### 📝 Stack 구조

원통을 자료구조 Stack, 구슬을 데이터(data)로 비유할 수 있습니다. 우리가 구슬을 차례대로 원통에 넣었을 때 가장 나중에 넣은 구슬이 원통의 가장 상단에 자리 잡고 있고, 그렇기 때문에 구슬을 빼는 경우에 가장 나중에 넣었던, 원통 상단에 위치한 구슬을 가장 먼저 뺄 수 있습니다.

- Stack의 특징은 입력과 출력이 하나의 방향, 즉 스택의 최상단에서만 이루어지는 제한적 접근

- 이런 Stack 자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out)

- Stack에 데이터를 넣는 것을 'PUSH', 데이터를 꺼내는 것을 'POP'

#### 📝 Stack 특징

<span style="color:#90caf9"><strong>1. LIFO (Last In First Out) : 먼저 들어간 데이터는 제일 나중에 나오는 후입선출 구조 </strong></span>

```js
// 1, 2, 3, 4 차례대로 스택에 넣으면

stack.push(데이터)

| 4 |
| 3 |
| 2 |
| 1 |

// 들어간 순서대로, 1번이 제일 먼저 들어가고 4번이 마지막으로 들어감

// 스택이 빌때까지 데이터 전부 빼내면

|  |
|  |
|  |
|  |

// 4, 3, 2, 1 즉, 제일 마지막 데이터부터 차례대로 나옴
```

이러한 특성으로 인해 스택 구조 내에서 특정 데이터를 조회할 수 없으며, 스택의 최상단에서만 데이터를 저장하고 꺼낼 수 있는 특징이 있습니다.

그 때문에 데이터를 저장할 때나 검색할 때 항상 스택의 최상단에서만 행위가 이루어지며 이에 따라 데이터를 저장하고 검색하는 프로세스가 매우 빠릅니다.

<span style="color:#90caf9"><strong>2. 하나의 입출력 방향 </strong></span>

Stack 자료구조는 데이터를 넣고 뺄 수 있는 곳이 스택의 가장 최상단, 한 군데입니다. 즉 데이터를 넣을 때도 스택의 가장 최상단으로 넣고(입력) 뺄 때 또한 스택의 가장 최상단으로 데이터를 뺄 수(출력) 있습니다.

<span style="color:#90caf9"><strong>3. 데이터는 하나씩 넣고 뺄 수 있음 </strong></span>

스택에 한 개씩 여러 번 데이터를 넣어 스택 내부에 데이터가 여러 개 쌓여 있다고 하더라도, 데이터를 뺄 때는 스택의 가장 최상단에서 한 번에 한 개의 데이터만을 뺄 수 있습니다.

---

### ✔️ Queue ??

큐(Queue)는 줄을 서서 기다리다, 대기행렬의 의미를 지니며 예를 들어 명절에 고향으로 가기 위해 많은 자동차가 고속도로를 지납니다. 고속도로에는 톨게이트가 있고, 자동차는 톨게이트에 진입한 순서대로 통행료를 내고 톨게이트를 통과합니다. 이 때 톨게이트를 Queue, 자동차를 데이터에 비유할 수 있습니다.

#### 📝 Queue 구조

가장 먼저 진입한 자동차가 가장 먼저 톨게이트를 통과합니다. 즉, 가장 나중에 진입한 자동차는 먼저 도착한 자동차가 모두 빠져나가기 전까지는 톨게이트를 빠져나갈 수 없습니다. Queue는 선입선출의 구조를 가지고 있습니다.

먼저 들어간 데이터(data)가 먼저 나오는 FIFO(First In First Out) 혹은 LILO(Last In Last Out)을 특징으로 가지고 있습니다.

입력의 방향과 출력의 방향이 각각 고정되어 있으며, 데이터를 입력할 시에는 큐의 끝에서(tail), 데이터를 출력할 때는 큐의 맨 앞에서(head) 진행됩니다. Queue에 데이터를 넣는 것을 'enqueue', 데이터를 꺼내는 것을 'dequeue'라고 합니다.

#### 📝 Queue 특징

<span style="color:#90caf9"><strong>1. FIFO(First In First Out) : 선입선출</strong></span>

```js
// 1, 2, 3, 4를 큐에 차례대로 넣음

                queue.enqueue(데이터)
출력 방향(head) <---------------< 입력방향 (데이터)

// 들어간 순서대로, 1번이 제일 먼저 들어가고 4번이 마지막으로 들어감

// 큐가 빌 때까지 전부 빼냄

                queue.dequeue(데이터)
출력 방향(head)	 <--------------------< 입력 방향(tail)

<--------------------<

1, 2, 3, 4

// 제일 첫 번째 데이터부터 차례대로 나옴
```
<span style="color:#90caf9"><strong>2. 2개의 입출력 방향 </strong></span>

데이터를 입력할 때는 큐의 맨 끝(tail)으로만 입력이 가능하며 데이터를 출력할 때는 큐의 맨 앞(head)으로만 출력이 가능합니다.

즉, 큐는 데이터를 입력하는 곳과 출력하는 곳이 각각 정해져 있으며 이렇게 총 2개의 입출력 방향을 가지고 있습니다.

<span style="color:#90caf9"><strong>3. 데이터는 하나씩 넣고 뺄 수 있습니다. </strong></span>

큐에 한 개씩 여러 번 데이터를 넣어 큐 내부에 데이터가 여러 개 쌓여 있다고 하더라도, 데이터를 뺄 때는 큐의 맨 앞에서 한 번에 한 개의 데이터만을 뺄 수 있습니다.

#### 📝 원형 큐 (Circular Queue)

---

###  ✔️ 예제

#### 🤔 Stack 구현 - 배열

```js
//const stack = new Array(); 미리 정의된 Array 객체를 사용할 수 있습니다.

const stack = [];

stack.push(1); // [1]
stack.push(2); // [1, 2]
stack.push(3); // [1, 2, 3]
stack.push(4); // [1, 2, 3, 4]
stack.push(5); // [1, 2, 3, 4, 5]

console.log(stack); // [1, 2, 3, 4, 5]

//제일 마지막에 들어간 요소부터 빼내기 위해 pop() 메소드를 사용합니다.
stack.pop(); // [1, 2, 3, 4]
stack.pop(); // [1, 2, 3]

console.log(stack); // [1, 2, 3]
```
#### 🤔 Queue 구현 - 배열

```js
//const queue = new Array(); 미리 정의된 Array 객체를 사용할 수 있습니다.
const queue = [];

queue.push(1); // [1]
queue.push(2); // [1, 2]
queue.push(3); // [1, 2, 3]
queue.push(4); // [1, 2, 3, 4]
queue.push(5); // [1, 2, 3, 4, 5]

console.log(queue); // [1, 2, 3, 4, 5]

//제일 먼저 들어간 것부터 빼내기 위해 shift() 메소드를 사용합니다.
queue.shift(); // [2, 3, 4, 5]
queue.shift(); // [3, 4, 5]

console.log(queue); // [3, 4, 5]
```
