# 1. Tree & Graph

### ✔️ Tree ??

Tree는 나무의 형태, 정확히는 나무를 뒤집어 놓은듯한 모습을 가지고 있습니다. 그래프의 여러 구조 중 단방향 그래프의 한 구조로, 하나의 뿌리로부터 가지가 사방으로 뻗은 형태가 나무와 닮았다 해서 트리 구조라고 부릅니다.

<img src = "https://postfiles.pstatic.net/MjAyMzA3MTBfMTUy/MDAxNjg4OTY2NjYzOTAx.I3tY7czKLWsdnml0zHXaNHIrkxvnkQe2lmExIkG6wMkg.7C41tzkgAuvi0w1rhh5TAv9pIEQ_exO_fThJBBozO2Qg.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-10_142359.png?type=w773" width = 450 height = 300>

이 트리의 구조는 데이터가 바로 아래에 있는 하나 이상의 데이터에 한 개의 경로와 하나의 방향으로만 연결된 계층적 자료구조입니다. 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 비선형 구조입니다.

대표적인 사례로는 월드컵 토너먼트 대진표, 조직도, 가계도 등이 있습니다.

#### 📝 Tree 구조 및 특징

<img src = "https://postfiles.pstatic.net/MjAyMzA3MTBfMTA0/MDAxNjg4OTY3NzI4NzA5.cARl0ZqtXr5jkr_U5GFhc6Bj-x57fsoNo4e9pDISkngg.dnjaJHDvKj1DJ-Op4uLWC6XVoOBopDt3l_LCtm7ZS1og.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-10_144200.png?type=w773" width = 450 height = 300>

> - 노드(Node) : 트리 구조를 이루는 모든 개별 데이터
> - 루트(Root) : 트리 구조의 시작점이 되는 노드
> - 부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
> - 자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
> - 리프(Leaf) : 트리 구조의 끝 지점이고, 자식 노드가 없는 노드

트리 구조는 루트(Root)라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결합니다. 각 데이터를 노드(Node)라고 하며, 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 맺습니다. 위 그림에서 A는 B와 C의 부모 노드(Parent Node)이고, B와 C는 A의 자식 노드(Child Node)입니다. 자식이 없는 노드는 나무의 잎과 같다고 하여 리프 노드(Leaf Node)라고 부릅니다.

#### 🤔 깊이 (Depth)

트리 구조에서는 루트로부터 하위 계층의 특정 노드까지의 깊이를 표현할 수 있으며 루트 노드는 지면에 있는 것처럼 깊이가 0, 즉, A의 깊이는 0이며, B와 C의 깊이는 1, D, E, F, G의 깊이는 2입니다.

#### 🤔 레벨 (Level)

트리 구조에서 같은 깊이를 가진 노드를 묶어서 레벨로 표현할 수 있습니다. 깊이가 0인 루트 A는 level 1, 깊이가 1인 노드 B와 C는 level 2, 깊이가 2인 노드 D, E, F, G는 level 3입니다. 같은 레벨에 나란히 있는 노드를 형제 노드 (Sibling Node)라고 합니다.

#### 🤔 높이 (Height)

트리 구조에서 리프 노드를 기준으로 루트까지의 높이를 표현할 수 있습니다. 리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 높이 값에 +1을 한 값을 높이로 가집니다. 이때 리프 노드의 높이를 0으로 두며, H, I, J의 높이는 0입니다. 따라서 B, C는 2, 최상단 A는 3입니다.

#### 🤔 서브 트리 (Sub Tree)

트리 구조의 루트에서 뻗어 나오는 큰 트리의 내부에, 트리 구조를 갖춘 작은 트리를 서브 트리라고 부릅니다. (D, H, I)로 이루어진 작은 트리도 서브 트리이고, (B, D, E)나 (C, F, G, J)도 서브 트리입니다.

---

### ✔️ 이진트리(Binary tree) & 이진 탐색 트리 (Binary Search Tree)

#### 📝 이진트리 

이진트리는 자식 노드가 최대 두 개인 노드로 구성된 트리이며, 이 두 개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있습니다.

자료의 삽입, 삭제 방법에 따라 정 이진트리, 완전 이진트리, 포화 이진트리로 나눌 수 있습니다.

<img src = "https://postfiles.pstatic.net/MjAyMzA3MTBfNCAg/MDAxNjg4OTY4NDUxMzM1.2ZctfTkJNq87Y7ig0XuqNEgZopLuv8APyasM6uAupBog.5ews68bs0K_EkJhhQy3BiHLl8YLJzBEWAmdGyL66ZmMg.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-10_145354.png?type=w773">


- 특징

1.  정 이진트리(Full binary tree) : 각 노드가 0개 혹은 2개의 자식 노드를 갖습니다.

2. 포화 이진트리(Perfect binary tree) : 정 이진트리이면서 완전 이진트리인 경우입니다. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리입니다.

3. 완전 이진트리(Complete binary tree) : 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 합니다.

#### 📝 이진 탐색 트리

이진 탐색의 속성이 이진트리에 적용된 특별한 형태의 트리이며, 이진 탐색 알고리즘이란 정렬된 데이터 중에서 특정한 값을 찾기 위한 탐색 알고리즘 중 하나입니다.

이진 탐색 알고리즘은 오름차순으로 정렬된 정수의 배열을 같은 크기의 두 부분 배열로 나눈 후, 두 부분 중 탐색이 필요한 부분에서만 탐색하도록 탐색 범위를 제한하여 원하는 값을 찾는 알고리즘입니다.

> - 배열 중간에 내가 찾고자 하는 값 존재 확인
> - 중간 앖이 내가 찾는 값이 아닌 경우, 오름차순으로 정렬된 배열에서 중간값보다 큰 값인지 확인
> - 찾고자 하는 값이 중간값보다 작은 값일 경우, 배열의 맨 앞부터 중간값 전까지의 범위를 탐색 범위로 잡고 탐색을 반복 수행
> - 찾고자 하는 값이 중간값보다 큰 값일 경우, 배열의 중간값의 다음 값부터 맨 마지막까지를 탐색 범위로 잡고 탐색을 반복 수행

이진 탐색 트리는 루트 노드가 리스트의 중간 값이 되며, 왼편 서브 트리들은 모든 루트노드의 값보다 작은 값, 오른편 서브 트리들은 루트노드보다 큰 값이어야 합니다.

🤔 특징은 다음과 같습니다.

1. 각 노드에 중복되지 않은 키 존재

2. 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들

3. 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들

4. 좌우 서브 트리도 모두 이진 탐색 트리여야 함

---

### ✔️ Tree Traversal

#### 📝 전위 순회

전위 순회에서 가장 먼저 방문하는 노드는 루트 노드이며 루트에서 시작해 왼쪽의 노드들을 순차적으로 둘러본 뒤, 왼쪽의 노드 탐색이 종료도면 오른쪽 노드를 탐색합니다. 

 즉 부모 노드가 제일 먼저 방문되는 순회 방식입니다. 전위 순회는 주로 트리를 복사할 때 사용합니다.


#### 📝 중위 순회

중위 순회는 루트를 가운데 두고 순회하며 제일왼쪽 끝에 있는 노드부터 순회하기 시작하여 루트를 기준으로 왼쪽에 있는 노드의 순회가 끝나면 루트를 거쳐 오른쪽에 있는 노드로 이동하여 마저 탐색합니다.

부모 노드가 서브 트리의 방문 중간에 방문되는 순회방식입니다. 중위 순회는 이진 탐색 트리의 오름차순으로 값을 가져올 때 사용합니다.

#### 📝 후위 순회

후위 순회는 루트를 가장 마지막에 순회하며, 제일 왼쪽 끝에 있는 노드부터 순회하기 시작하여, 루트를 거치지 않고 오른쪽으로 이동해 순회한 뒤, 제일 마지막에 루트를 방문합니다. 

후위 순회는 트리를 삭제할 때 사용합니다. 자식 노드가 먼저 삭제되어야 상위 노드를 삭제할 수 있기 때문입니다.

#### 📝 레벨 순회

레벨 순회는 루트를 방문하는 기준으로 순회를 하는 것이 아닌 트리의 레벨 기준으로 노드들을 방문하는 순회 방법입니다.

루트 노드를 시작으로 아래로 뻗어나가며 노드들을 방문하며 루트 노드의 레벨이 1이라고 했을 때 아래로 내려갈수록 레벨은 증가하는 특징을 보입니다.

동일한 레벨에 여러 노드가 존재할 경우 왼쪽에서 오른쪽 순서로 노드를 방문합니다.

---

### ✔️ Graph

그래프는 여러 개의 점이 서로 복잡하게 연결된 관계를 표현한 구조입니다. 자료구조의 그래프는 일반 그래프와 달리 x, y축이 존재하는 수학적 자료가 아니라 마치 거미줄처럼 여러개의 점이 선으로 이어져 있는 복잡한 네트워크망과 같은 모습을 가지고 있습니다.

#### 📝 Graph 구조

- 직접적 관계가 있는 경우, 두 점 사이를 이어주는 선 존재

- 간접적인 관계면 몇 개의 점과 선에 걸쳐 이어짐

- 하나의 점을 그래프에서는 정점이라 표현하며, 하나의 선은 간선이라고 부름

#### 📝 Graph 표현 방식

- 인접 행렬

    두 정점을 바로 이어주는 간선이 있다면 이 두 정점은 인접하다고 이야기합니다. 인접 행렬은 서로 다른 정점들이 인접한 상태인지를 표시한 행렬로 2차원 배열의 형태로 나타냅니다. 만약 A라는 정점과 B라는 정점이 이어져 있다면 1(true), 이어져 있지 않다면 0(false)으로 표시한 일종의 표입니다. 만약 가중치 그래프라면 1 대신 관계에서 의미 있는 값을 저장합니다.

```js
// 1. A의 진출차수는 1개 ( A → C)

[0][2] === 1 //  A([0])는 C([2])로 가는 진출차수가 있다(1)

// 2. B의 진출차수는 2개 (B → A , B → C)

[1][0] === 1 // B([1])는 A([0])로 가는 진출차수가 있다(1)
[1][2] === 1 // B([1])는 C([2])로 가는 진출차수가 있다(1)

// 3. C의 진출차수는 1개 (C → A)

[2][0] === 1 // C([2])는 A([0])로 가는 진출차수가 있다(1)
```

- 인접 리스트

    인접 리스트는 각 정점이 어떤 정점과 인접하는지를 리스트의 형태로 표현하며, 각 정점마다 하나의 리스트를 가지고 있고, 이 리스트는 자신과 인접한 다른 정점을 담고 있습니다.

    1. A → C → Null

    2. B → A → C → Null

    3. C → A → Null


#### 🤔 인접 행렬과 인접 리스트는 각각 언제 사용할까 ???

<span style="color:#90caf9"><strong>인접 행렬의 경우 </strong></span>

1. 한 개의 큰 표와 같은 모습을 한 인접 행렬은 두 정점 사이에 관계가 있는지, 없는지 확인하기에 용이합니다.

    - 예를 들어, A에서 B로 진출하는 간선이 있는지 파악하기 위해선 0번째 줄의 1번째 열에 어떤 값이 저장되어있는지 바로 확인할 수 있습니다.
2. 가장 빠른 경로(shortest path)를 찾고자 할 때 주로 사용됩니다.

- 최단 경로를 구하는 과정(BFS)에서는 그래프 탐색이 빈번하게 발생하는데, 이때 인접행렬이 인접리스트에 비해 조회 성능이 우수합니다. 인접행렬의 경우 인덱스를 직접 접근하여 조회가 O(1)로 이루어지기 때문입니다. 

    반면, 인접리스트의 경우 각 row를 선형 조회해야 하므로 노드의 수가 N일 경우 O(N)의 시간이 소요됩니다.

    정리하자면, 인접리스트의 경우 A 노드에서 B 노드로 이동하는 경우만 해도 O(N)의 시간이 소요되며, 더불어 최단 경로를 구하는 과정 자체에서도 시간이 많이 소요되기 때문에 
    인덱스를 통한 직접 접근이 가능한 인접행렬이 최단경로를 찾는 데 더 유리한 측면이 있다는 것입니다.


<span style="color:#90caf9"><strong>인접 리스트의 경우 </strong></span>

1. 메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용합니다.

    - 인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지합니다.

#### 📝 Graph 용어 정리

- 정점 (vertex): 노드(node)라고도 하며 데이터가 저장되는 그래프의 기본 원소입니다.

- 간선 (edge): 정점 간의 관계를 나타냅니다. (정점을 이어주는 선)
- 인접 정점 (adjacent vertex): 하나의 정점에서 간선에 의해 직접 연결된 정점

- 가중치 그래프 (weighted Graph): 연결의 강도(추가적인 정보, ex. 서울-부산으로 가는 거리 등)가 얼마나 되는지 적혀 있는 그래프

- 비 가중치 그래프 (unweighted Graph): 연결의 강도가 적혀 있지 않는 그래프

- 무향(무방향) 그래프 (undirected graph): 앞서 보았던 내비게이션 예제는 무향(무방향) 그래프

    서울에서 부산으로 갈 수 있듯, 반대로 부산에서 서울로 가는 것도 가능합니다. 하지만 단방향(directed) 그래프로 구현된다면 서울에서 부산으로 갈 수 있지만, 부산에서 서울로 가는 것은 불가능합니다(혹은 그 반대). 만약 두 지점이 일방통행 도로로 이어져 있다면 단방향인 간선으로 표현할 수 있습니다.

- 진입차수 (in-degree) / 진출차수 (out-degree): 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지를 나타냅니다.

- 인접 (adjacency): 두 정점 간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점
- 자기 루프 (self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다라고 표현합니다. 다른 정점을 거치지 않는다는 것이 특징

- 사이클 (cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현합니다. 내비게이션 그래프는 서울 —> 대전 —> 부산 —> 서울로 이동이 가능하므로, 사이클이 존재하는 그래프입니다.

---

### ✔️ BFS (Breadth-First-Search) & DFS(Depth-First-Search)

#### 📝 BFS

너비를 먼저 탐색하는 방법을 Breadth-First Search, 너비 우선 탐색이라고 합니다. 주로 두 정점 사이의 최단 경로를 찾을 때 사용합니다. 만약, 경로를 하나씩 전부 방문한다면, 최악의 경우에는 모든 경로를 다 살펴보아야 합니다.

한 경로를 끝까지 모두 다 탐색하는 처음 발견한 답이 최단 거리가 아닐 수 있지만, BFS는 현재 있는 노드에서 가까운 곳부터 탐색하므로 경로를 탐색하는 도중 가장 먼저 발견한 해답이 최단거리라는 보장이 되기 때문에 최단 경로를 찾을 때 BFS 방식을 사용합니다.

#### 📝 DFS

깊이를 먼저 탐색하는 방법을 Depth-First Search, 깊이 우선 탐색이라고 합니다. 한 정점에서 시작해서 다음 경로로 넘어가기 전에 해당 경로를 완벽하게 탐색할 때 사용합니다. BFS보다 탐색 시간은 조금 오래 걸릴지라도 모든 노드를 완전히 탐색할 수 있습니다.