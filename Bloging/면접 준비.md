# 📝 면접 질문 리스트 !

### ✔️ 개발자로서

<span style="color:#90caf9"><strong> 🤔 개발자로서 자신의 장점, 약점은 무엇인가요? </strong></span>

(자신의 약점에 대한 보완을 얼마나 성실하고 지속적으로 하고 있는지에 대한 내용)

<span style="color:#90caf9"><strong> 🤔 어떤 프레임워크를 사용해보셨나요? 그 프레임워크의 장점은 무엇인가요? </strong></span>

저는 React를 사용하여 개발을 했습니다. React는 사용자 인터페이스 구축과 관리를 쉽게 할 수 있는 사용자 인터페이스 라이브러리입니다. 또한 리액트 컴포넌트는 모듈화되어 있어서 재사용성이 높고, 코드의 가독성이 좋습니다.

<span style="color:#90caf9"><strong> 🤔 브라우저 렌더링 과정에 대해서 설명해 주세요. </strong></span>

브라우저는 웹 페이지를 렌더링하는 과정에서 HTML, CSS, JavaScript 파일을 해석하고 화면에 표시하는 과정을 거칩니다. 먼저 HTML 파일을 해석하여 DOM 트리를 생성하고, CSS 파일을 해석하여 CSSOM 트리를 생성합니다. 이후에 JavaScript 파일을 해석하여 화면에 표시되는 요소들을 동적으로 조작합니다. 이러한 과정을 통해 웹 페이지가 렌더링됩니다.

<span style="color:#90caf9"><strong> 🤔 가장 최근에 해결한 기술적인 문제는 무엇인가요? </strong></span>

(본인이 프로젝트에서 직접적으로 개선한 부분들을 말씀하시면 됩니다. 평소에 리팩토링 습관이 있으시다면 대답하시기 수월하실 거라 생각됩니다.)

<span style="color:#90caf9"><strong> 🤔  해당 프로젝트에서 자신의 역할은 무엇이었나요? </strong></span>

---

### ✔️ CSS

<span style="color:#90caf9"><strong> 🤔 Flex와 Grid의 차이점에 대해서 설명해보세요. </strong></span>

Flex는 주로 단일 축 방향의 레이아웃을 구성하는 데 사용되며, 주로 수평 방향으로 레이아웃을 정렬합니다. Grid는 2차원 그리드 시스템을 구성하는 데 사용되며, 수평과 수직 방향으로 모두 레이아웃을 정렬할 수 있습니다. Flex는 아이템들의 크기가 자유로워 유동적으로 변할 수 있습니다. 반면에 Grid는 아이템들의 크기를 미리 정의하여 각 셀의 크기를 일정하게 유지합니다. Flex는 유동적인 레이아웃 변화를 구성하기 적합합니다. 반면에 Grid는 미리 정의된 2차원 그리드 구조를 유지하기 때문에 레이아웃 변화가 적은 경우에 적합합니다.


---

### ✔️ JavaScript

<span style="color:#90caf9"><strong> 🤔 이벤트 버블링, 캡쳐링, 위임에 대해서 설명해 주세요. </strong></span>

이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, 상위 요소로 이벤트가 전파되는 현상을 말합니다. 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 장점이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 

이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 이벤트 위임 처리를 할 수 있습니다. 버블링 및 캡쳐링을 방지하기 위해서는 이벤트 객체의 stopPropagation() 메서드를 사용하여 이벤트 전파를 중지시키거나, 이벤트 핸들러에서 이벤트가 발생한 요소를 확인하여 처리해야 합니다.

이벤트 캡쳐링

이벤트 위임



<span style="color:#90caf9"><strong> 🤔 클로저에 대해서 설명해 주세요. </strong></span>

함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명입니다. 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성합니다. 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수 입니다. 정보를 은닉하기 위해서 주로 사용 합니다.

<span style="color:#90caf9"><strong> 🤔 `== (동등 연산자)`, `=== (일치 연산자)` 의 차이점에 대해서 설명해 주세요. </strong></span>

"=="는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행합니다. 즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교합니다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, "=="를 사용할 때는 조심해야 합니다. 

"==="는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교합니다. 따라서 "==="를 사용하면 형변환 없이 정확한 값을 비교할 수 있습니다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 호이스팅에 대해서 설명해 주세요. </strong></span>

호이스팅은 변수와 함수의 선언을 해당 스코프의 최상단으로 끌어올려져 실행되는 것을 의미합니다. 이로 인해 선언 전에 사용하는 경우 오류가 발생할 수 있습니다.

(변수 선언의 3단계 선언, 초기화, 할당 순서에 대해서 머릿 속에서 그리고 대답)

<span style="color:#90caf9"><strong> 🤔 Promise의 기능과 필요한 이유에 대해서 설명해 주세요. </strong></span>

자바스크립트 비동기 처리에 사용되는 객체, 비동기(특정 코드의 실행이 완료될때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성) 처리의 단점을 보완하여 동기적으로 처리할수있게 도와줍니다.
서버에서 받아온 데이터를 처리하기 위해 fetch등으로 서버에서 데이터를 요청하고 받아온 뒤 처리하기 위하여 Promise가 필요합니다.

<span style="color:#90caf9"><strong> 🤔 async/await에 대해서 설명해 주세요. </strong></span>

async/await는 비동기적인 작업을 처리할 수 있는 ES2017 문법 입니다. async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다. 

async/await는 Promise를 기반으로 하며, 코드를 보다 간결하고 직관적으로 작성할 수 있도록 해줍니다. async 함수는 항상 Promise 객체를 반환하며, await 키워드를 이용하여 비동기 처리 결과를 기다립니다.

<span style="color:#90caf9"><strong> 🤔 순수함수란 무엇인가요? 불변성과 사이드 이펙트와 연결하여 설명해 주세요. </strong></span>

순수 함수란 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수를 의미합니다. 사이드 이펙트는 쉽게 말해서 외부 변수를 참조하거나, 변경하는 모든 종류의 코드를 의미하는데, 이 사이드 이펙트가 없어야합니다. 

자바스크립트에서 순수함수를 제작하기 위해서 데이터의 불변성을 유지하는 것이 중요합니다. 함수의 전달인자로 참조 자료형이 전달되는 경우, 해당 객체 자체를 바꿔서 사이드 이펙트를 만들 수 있고, 이는 해당 데이터의 불변성을 손상시킬 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 비동기 함수에 대해서 설명해 주세요. </strong></span>

(이벤트 루프에 대해서도 꼭 알고 가기!)

비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 

비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 

이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.

---

### ✔️  React

<span style="color:#90caf9"><strong> 🤔 React의 state와 props에 대해서 설명해 주세요. </strong></span>


Rect state란 컴포넌트의 사용 중 컴포넌트 내부에서 변할 수 있는 값을 의미하고 props란 상위 컴포넌트로부터 전달 받은 값, 즉 외부로부터 전달받은 값을 의미합니다. React 컴포넌트는 props를 함수의 전달인자처럼 전달 받아 이를 기반으로 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환합니다.

<span style="color:#90caf9"><strong> 🤔 React 컴포넌트의 key 속성에 대해서 설명해 주세요. </strong></span>

key 속성은 같은 컴포넌트를 여럿 렌더링할 때, 다른 컴포넌트임을 구분하기 위해서 사용하는 속성입니다.

<span style="color:#90caf9"><strong> 🤔 useEffect의 dependency array에 대해서 설명해 주세요. </strong></span>

 useEffect란 컴포넌트 내에서 Side Effect를 실행할 수 있게 하는 Hook입니다. useEffect는 첫 번째 인자로 콜백 함수를 받고 두 번째 인자로 배열을 받는데 이 배열을 dependency array라고 부릅니다. dependency array, 즉 종속성 배열이라고 부르는 이유는 useEffect의 실행이 화면에 첫 렌더링 될때, 그리고 종속성 배열의 value값이 바뀔 때마다 실행되기 때문입니다.

<span style="color:#90caf9"><strong> 🤔 클래스형 컴포넌트와 함수형 컴포넌트의 차이점에 대해서 설명해 주세요. </strong></span>

클래스형 컴포넌트는 ES6의 클래스(class)를 사용하여 컴포넌트를 정의합니다. 이 방식은 React의 컴포넌트의 상태(state)와 생명주기(lifecycle)를 다룰 때 매우 유용합니다.
반면에 함수형 컴포넌트는 ES6의 화살표 함수(arrow function)를 사용하여 컴포넌트를 정의합니다. 이 방식은 훅(hook) API와 함께 많이 사용되며, 컴포넌트의 상태와 생명주기를 다룰 때도 유용합니다.

클래스형 컴포넌트와 함수형 컴포넌트의 가장 큰 차이점은 상태와 생명주기의 다루는 방식입니다. 클래스형 컴포넌트는 상태를 this.state로 정의하고, 생명주기 메서드를 오버라이드하여 다양한 작업을 수행합니다. 반면에 함수형 컴포넌트는 상태를 useState 훅을 사용하여 정의하고, useEffect 훅을 사용하여 생명주기를 다룹니다. 또한, 클래스형 컴포넌트에서는 this 키워드를 사용하여 상태나 메서드를 참조하며, 함수형 컴포넌트에서는 this 키워드를 사용하지 않습니다. 이러한 차이점 때문에, 함수형 컴포넌트는 더 간결하고 가독성이 좋아지며, 테스트와 리팩토링이 쉽게 이루어질 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 스토리북에 대해서 설명해 주세요. </strong></span>

스토리북(Storybook)은 UI 컴포넌트 개발을 위한 도구로, 개별 컴포넌트의 기능과 상태를 다양한 시나리오로 테스트하고, 문서화하여 관리할 수 있는 환경을 제공합니다. 이를 통해 UI 개발자와 디자이너는 컴포넌트의 독립적인 테스트와 문서화를 통해 작업 효율성과 코드 품질을 향상시킬 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 TDD에 대해서 설명해 주세요. </strong></span>

TDD(Test-Driven Development)는 테스트 주도 개발 방법론의 준말로, 개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다. TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다. 또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다

(Jest, Cypress, testing-library/react에 대한 학습 !!)

<span style="color:#90caf9"><strong> 🤔 Styled Components를 사용해 보면서 느낀 장점을 이야기해 주세요. </strong></span>

1. Styled-Components를 사용하면 CSS 코드가 작성된 컴포넌트가 곧 스타일을 적용할 컴포넌트이기 때문에 class와 id를 사용해서 요소를 특정하지 않아도 됩니다.

2. Styled Components를 사용하면 애초에 CSS 파일을 작성할 필요가 없기 때문에 CSS 파일에서 내가 원하는 부분을 찾기위해 시간을 쓰거나 길어진 CSS 파일을 쪼개서 관리할 필요가 없어졌습니다.

3.  CSS 파일을 작성하다보면 같은 종류의 요소에 같은 종류의 스타일 속성을 작성하게 되는 일이 종종 생기곤 하는데, Styled Components는 컴포넌트 단위로 스타일 속성을 작성하기 때문에 속성이 겹치는 일이 없었습니다.

<span style="color:#90caf9"><strong> 🤔 useRef가 필요한 상황을 예시를 들어 설명해 주세요. </strong></span>

useRef는 특정 요소의 DOM 주소값을 가져오는 React Hook입니다. React는 가상 DOM을 사용해서 SPA를 구현하기 때문에, DOM을 직접 조작하는 것은 React의 작동 방식과도 맞지 않고, 원하는 결과가 나오지 않을 수 있습니다. 

따라서, 예외의 상황이 아닌 경우는 DOM에 직접 접근해서는 안됩니다. DOM에 직접 접근해야하는 예외 상황들이 있는데, DOM 엘리먼트의 주소값을 활용해야 하는 경우로, 가장 대표적인 예시는 특정 요소에 포커스를 설정해야하는 상황이 있습니다.

이럴 때 useRef를 사용해서 DOM 주소 값을 받아와 사용할 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 상태관리 라이브러리의 필요성에 대해서 설명해 주세요. </strong></span>

Redux와 같은 상태관리 라이브러리는 전역 상태 저장소를 제공해줍니다. 기존의 React에서는 자식 컴포넌트에 props를 내려줘서 상태를 전달해줬습니다. 이 경우에는 해당 상태를 사용하지 않는 컴포넌트들도 오로지 상태를 전달해주기 위해서props를 받아야 했고, 이를 props drilling이라고 합니다.
상태 관리 라이브러리는 전역 상태 저장소를 제공해줌으로써 이 props drilling 문제를 해결해줍니다. 전역 상태 저장소가 있다면 props를 내려줄 필요없이 바로 이 저장소에 접근해서 필요한 상태를 가져다 사용하면 되기 때문입니다.

<span style="color:#90caf9"><strong> 🤔 Redux의 주요 개념들과 연결 관계를 설명해 주세요. </strong></span>

Redux의 주요 개념으로는 Action, Dispatch, Reducer, Store가 있으며, Action → Dispatch → Reducer → Store 순서로 데이터가 단방향으로 흐르게 됩니다.

Action은 어떤 액션을 취할 것인지 정의해 놓은 객체입니다. 해당 Action 객체가 어떤 동작을 하는지 명시해주는 type 속성을 가집니다.

Dispatch는 Reducer로 Action을 전달해주는 함수입니다. Dispatch의 전달인자로 Action 객체가 전달되며. Action 객체를 전달받은 Dispatch 함수는 Reducer를 호출합니다.

Reducer는 Dispatch에게서 전달받은 Action 객체의 type 값에 따라서 상태를 변경시키는 함수로, Reducer가 리턴하는 값이 새로운 상태가 됩니다. 이 때, Reducer는 순수함수여야 합니다. 외부 요인으로 인해 기대한 값이 아닌 엉뚱한 값으로 상태가 변경되는 일이 없어야하기 때문입니다.

Store는 Redux의 전역 저장소로, Redux 앱의 state가 저장되어 있는 오직 하나뿐인 저장소의 역할을 합니다.

---

### ✔️ HTTP/네트워크 , 웹 서버

<span style="color:#90caf9"><strong> 🤔 Restful API에 대해서 설명해 주세요. </strong></span>

RESTful API는 웹 서비스에서 사용되는 아키텍처 스타일로, 웹 서비스의 자원을 정의하고 자원에 대한 조작을 위한 인터페이스를 정의하는 것을 의미합니다. 또한 표준 HTTP 메서드를 사용하여 자원을 조작하는 것을 의미합니다. (HTTP 메서드는 GET, POST, PUT, DELETE 등이 있습니다. - 꼬리 질문 예상)


<span style="color:#90caf9"><strong> 🤔 CSR과 SSR의 차이점에 대해서 설명해 주세요. </strong></span>

SSR과 CSR의 주요 차이점은 페이지가 렌더링되는 위치입니다. SSR은 서버에서 페이지를 렌더링하고, CSR은 브라우저(클라이언트)에서 페이지를 렌더링합니다. CSR은 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침하지 않고, 동적으로 라우팅을 관리합니다. SSR은 경로가 변경될 때마다 새로운 정적파일을 요청합니다.

<span style="color:#90caf9"><strong> 🤔 GET 메서드와 POST 메서드의 차이점에 대해 설명해 주세요. </strong></span>

GET 메서드는 존재하는 자원에 대한 요청을 위한 메서드, 즉 서버의 리소스를 조회하는 역할이고 POST 메서드는 새로운 자원을 생성하기 위한 메서드 즉, 서버의 리소스 변경을 위한 역할을 합니다.

<span style="color:#90caf9"><strong> 🤔 HTTP 메시지 구조에 대해 설명해 주세요. </strong></span>

 HTTP 메시지는 크게 start-line, header와 body로 나뉩니다. start-line은 어떤 프로토콜을 사용하는지, 어떤 HTTP 메서드인지, 상태 코드는 무엇인지 등 해당 요청 / 응답의 핵심 정보가 담겨있습니다.
header는 요청/응답에서 공통으로 자주 다루는 정보들이 담겨있습니다. 예를 들면 body의 Content-type이 무엇인지, 캐시의 유효 기간은 얼마나 되는지 등 공통으로 자주 주고받는 정보가 담겨있습니다. body는 해당 요청/ 응답에서 꼭 다뤄야 하는 중요한 정보를 담고 있습니다. 보통 추가/변경/삭제하고 싶은 리소스의 자세한 정보를 담기도 하고, 응답의 경우 요청자가 꼭 알아야하는 리소스에 대한 정보를 담게 됩니다.

<span style="color:#90caf9"><strong> 🤔 Same-Origin Policy와 CORS에 대해서 설명해 주세요. </strong></span>

 SOP는 Same Origin Policy의 줄임말로, 동일 출처 정책을 의미합니다. uri의 프로토콜, 호스트, 포트 이 3가지가 모두 동일해야 같은 출처(Same Origin)으로 인정하게 되는데요, 이 정책이 필요한 이유는 동일한 출처가 아닌 곳에서 요청이 오는 경우 해당 요청을 막아 높은 보안성을 유지하기 위함입니다. 대부분의 모던 브라우저에서는 이 정책을 기반으로 동일 출처로의 요청이 아니면 요청 자체를 막습니다. 크롬, Edge, Firefox와 같은 모던 웹 브라우저 사용을 권장하는 이유입니다.

다만, 서버에서 다른 출처에서의 요청을 허용하게 해줄 수 있는 CORS 설정을 해준 경우는 접근할 수 있습니다. 모든 출처로 부터의 요청을 허용할 수도 있고, 일부 출처로의 요청만 허용하는 것도 가능합니다. expressjs에서는 cors 미들웨어로 상황에 맞게 cors 설정을 제어할 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 IP 프로토콜의 한계에 대해서 설명해 주세요. </strong></span>

IP 프로토콜은 두 사용자가 패킷 교환 방식으로 정보를 주고 받을 때 사용하는 통신 규약입니다. IP 프로토콜의 한계로는 비연결성, 비신뢰성이 있습니다. 인터넷 프로토콜(IP)는 패킷 단위로 통신하며, IP 패킷은 소포처럼 출발지 IP 주소, 목적지 IP 주소 정보를 포함하고 있습니다.

패킷은 한 번 전송되면 목적지에 도착할 때까지 인터넷 망의 수많은 노드를 지나게 되는데 
이 때, 패킷을 받을 대상이 없거나 서비스 불능 상태여도 클라이언트는 서버의 상태를 파악할 방법이 없기 때문에 패킷을 그대로 전송하게 됩니다. 이걸 비연결성이라고 합니다.

또한 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없습니다. 목적지에서도 패킷의 순서가 바뀌거나 소실된 상태로 도착할 수 있습니다. 이걸 비신뢰성이라고 합니다.

<span style="color:#90caf9"><strong> 🤔 HTTP 프로토콜의 특징에 대해 설명해 주세요. </strong></span>

HTTP는 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있으며, 무상태성, 비연결성이라는 특징을 갖습니다.

무상태성은 서버가 클라이언트의 상태를 기억하지 않는다는 뜻입니다. 즉, 상태 기억의 주체가 클라이언트가 된다는 말이며, 중간에 요청을 처리하는 서버가 바뀌어도 클라이언트가 상태를 잘 담아서 요청을 보내면 응답을 제대로 받을 수 있습니다. 서버가 바뀌어도 응답에 문제가 없다는 뜻은, 필요에 따라 서버를 무한히 증설할 수 있다는 뜻입니다.

비연결성은 요청과 응답을 주고받은 후에 서버와의 연결을 끊는 것을 의미합니다. 서버와의 연결을 지속하지 않고 필요할 때에만 연결하기 때문에 최소한의 자원만 사용하게 된다는 장점이 있습니다. 하지만 HTTP 1.0 버전은 여러 요청을 보내야 할 때에도 매 요청마다 서버 연결과 종료를 반복하는 비효율성이 발생한다는 한계가 있습니다. 이러한 한계점을 HTTP 1.1 버전에서는 지속 연결을 활용해서 해결합니다.

---

#### ✔️ 인증 / 보안

<span style="color:#90caf9"><strong> 🤔 Cookie의 MaxAge, Expires 옵션이 무엇인지, 설정하지 않으면 어떻게 되는지 설명해 주세요. </strong></span>

Cookie는 HTTP 프로토콜의 비상태성을 보완하기 위한 수단으로, 브라우저에 데이터를 저장할 때 사용합니다. Cookie의 MaxAge 옵션은 쿠키를 얼마나 유지할 것인지, Expires 옵션은 언제 폐기할 것인지 지정하는 옵션입니다. 두 옵션을 동시에 설정하면 MaxAge가 더 높은 우선 순위로 적용됩니다.

이 두 옵션중 하나라도 설정하지 않으면,해당 쿠키는 브라우저가 닫힐 때 폐기 됩니다. 따라서 쿠키를 빠르게 폐기하고 싶다면 옵션을 설정하지 않는 것이 좋고, 쿠키를 계속 사용하고 싶다면 두 옵션 중에 하나라도 설정해주는 것이 좋습니다.

이 때, 브라우저를 종료하면 삭제되는 임시 쿠키를 세션 쿠키(Session Cookie)라고 하고, 설정한 옵션만큼 사용가능한 쿠키를 영속성 쿠키(Persistent Cookie)라고 합니다.

<span style="color:#90caf9"><strong> 🤔 CSRF나 XSS 공격을 막는 방법에 대해서 설명해 주세요. </strong></span>

CSRF 공격을 막기 위해서는 서버에서 CSRF Token을 생성하여 세션에 저장하고, 프론트엔드에서 요청 시 해당 Token을 함께 전송하여 인증합니다. SameSite 속성을 쿠키에 설정하여 도메인이 다른 사이트에서는 쿠키를 사용할 수 없도록 제한하는 방법도 있습니다. XSS 공격을 막기 위해서는 입력 값들을 유효성 검증하고, 특수문자들을 제외하는 정규식을 통해서 제거합니다. 또, 서버에서 CSP(Content-Security-Policy)정책을 설정하여, 허용된 스크립트만 실행되도록 제한 할 수도 있습니다. 마지막으로, HTTP 대신에 신뢰할 수 있는 HTTPS를 사용하여 통신 프로토콜을 암호화할 수 있습니다.

---

### ✔️ 알고리즘

<span style="color:#90caf9"><strong> 🤔 재귀를 활용하기 좋은 상황은 언제인지 예시를 들어 설명해 주세요. </strong></span>

첫 번째는 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우입니다. 예시로는 피보나치 수열의 n번째 수를 구하는 문제가 있습니다. 피보나치 수열의 n번째 수는 n-1번째 수와 n-2번 째 수를 합한 값입니다. 몇 번째 수를 구하든 동일한 구조의 작은 문제로 나눌 수 있는 구조인 것입니다. 이런 상황에서 재귀를 활용하면 간결한 코드로 문제를 해결할 수 있습니다.

두 번째는 중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우입니다. 예시로는 객체를 문자열로 바꾸는 함수가 있습니다. 객체는 배열이나 객체도 담을 수 있으며, 얼마나 중첩되어 있을지 예측하기 어렵기 때문에 반복문을 사용하기에는 적합하지 않습니다. 이럴 때 재귀를 활용하면 가장 깊은 곳에 있는 배열이나 객체까지 확인할 수 있습니다. 

---

### ✔️ UI/UX , 웹 표준 & 웹 접근성

<span style="color:#90caf9"><strong> 🤔 UI, UX의 개념과 두 개념의 관계에 대해서 설명해 주세요. </strong></span>

UI는 사람들이 컴퓨터와 상호 작용하는 시스템 즉, UI는 보통 화면상의 그래픽 요소인 GUI를 의미합니다.

UX는 사용자가 어떤 시스템, 제품, 서비스를 직•간접적으로 이용하면서 느끼고 생각하는 총체적 경험을 의미합니다. 제품, 서비스 그 자체에 대한 경험은 물론, 홍보, 접근성, 사후 처리 등 직간접적으로 관련된 모든 경험을 사용자 경험이라고 할 수 있습니다.

UX는 UI를 포함합니다. 또한 좋은 UX가 좋은 UI를 의미하거나, 좋은 UI가 항상 좋은 UX를 보장하지는 않습니다. 하지만, 나쁜 UI는 보통 나쁜 UX를 유발합니다. 프론트엔드 개발자는 UI를 개선함으로써 UX를 개선할 수 있으며, UX가 좋지 않은 곳에서 UI 개선점을 찾아낼 수도 있습니다.

<span style="color:#90caf9"><strong> 🤔 Semantic HTML의 필요성을 예시를 들어 설명해 주세요. </strong></span>

HTML에는 많은 종류의 요소가 있지만, div와 span tag 두 가지 요소만 알아도 충분히 화면의 구조를 만들 수 있습니다. 하지만, 이 두 요소의 이름에는 의미가 없기 때문에 요소의 이름으로는 각 요소가 어떤 역할을 하는지 알 수 없습니다.

 header, main, nav, footer tag 등 시맨틱 요소를 사용하면 요소의 이름만 보고도 해당 요소가 어떤 역할을 하는지, 요소가 가진 의미를 통해 파악할 수 있게 됩니다.

시맨틱 HTML을 작성하면 요소의 이름만 봐도 의미를 파악할 수 있기 때문에 그만큼 의미를 전달하기 위한 시간과 id, class 작성에 필요한 시간 소모도 줄어들고 개발자간 소통이 원활해집니다.

검색 엔진은 HTML 코드를 보고 문서의 구조를 파악하기 때문에 시맨틱 요소를 사용함으로써 HTML에 의미를 부여하는 것만으로도 검색 효율성을 높일 수 있습니다.

마지막으로 시맨틱 요소를 사용하면 화면의 구조를 짜는 것을 넘어 구조에 대한 정보를 전달할 수 있어 요소에 담긴 콘텐츠도 더 명확하게 전달할 수 있으므로 웹 접근성을 향상시킬 수 있습니다