# 📝 면접 질문 리스트 !

### ✔️ JavaScript


<span style="color:#90caf9"><strong> 🤔 Promise의 기능과 필요한 이유에 대해서 설명해 주세요. </strong></span>

자바스크립트 비동기 처리에 사용되는 객체, 비동기(특정 코드의 실행이 완료될때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성) 처리의 단점을 보완하여 동기적으로 처리할수있게 도와준다.
서버에서 받아온 데이터를 처리하기 위해 fetch등으로 서버에서 데이터를 요청하고 받아온 뒤 처리하기 위하여 Promise가 필요하다.

<span style="color:#90caf9"><strong> 🤔 순수함수란 무엇인가요? 불변성과 사이드 이펙트와 연결하여 설명해 주세요. </strong></span>

순수 함수란 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수를 의미합니다. 사이드 이펙트는 쉽게 말해서 외부 변수를 참조하거나, 변경하는 모든 종류의 코드를 의미
하는데, 이 사이드 이펙트가 없어야합니다. 자바스크립트에서 순수함수를 제작하기 위해서 데이터의 불변성을 유지하는 것이 중요합니다. 함수의 전달인자로 참조 자료형이 전달되는 경우, 해당 객체 자체를 바꿔서 사이드 이펙트를 만들 수 있고, 이는 해당 데이터의 불변성을 손상시킬 수 있습니다.

---

### ✔️  React

<span style="color:#90caf9"><strong> 🤔 React의 state와 props에 대해서 설명해 주세요. </strong></span>


Rect state란 컴포넌트의 사용 중 컴포넌트 내부에서 변할 수 있는 값을 의미하고 props란 상위 컴포넌트로부터 전달 받은 값, 즉 외부로부터 전달받은 값을 의미합니다. React 컴포넌트는 props를 함수의 전달인자처럼 전달 받아 이를 기반으로 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환합니다.

<span style="color:#90caf9"><strong> 🤔 React 컴포넌트의 key 속성에 대해서 설명해 주세요. </strong></span>

key 속성은 같은 컴포넌트를 여럿 렌더링할 때, 다른 컴포넌트임을 구분하기 위해서 사용하는 속성입니다.

<span style="color:#90caf9"><strong> 🤔 useEffect의 dependency array에 대해서 설명해 주세요. </strong></span>

 useEffect란 컴포넌트 내에서 Side Effect를 실행할 수 있게 하는 Hook입니다. useEffect는 첫 번째 인자로 콜백 함수를 받고 두 번째 인자로 배열을 받는데 이 배열을 dependency array라고 부릅니다. dependency array, 즉 종속성 배열이라고 부르는 이유는 useEffect의 실행이 화면에 첫 렌더링 될때, 그리고 종속성 배열의 value값이 바뀔 때마다 실행되기 때문입니다.


<span style="color:#90caf9"><strong> 🤔 Styled Components를 사용해 보면서 느낀 장점을 이야기해 주세요. </strong></span>

1. Styled-Components를 사용하면 CSS 코드가 작성된 컴포넌트가 곧 스타일을 적용할 컴포넌트이기 때문에 class와 id를 사용해서 요소를 특정하지 않아도 됩니다.

2. Styled Components를 사용하면 애초에 CSS 파일을 작성할 필요가 없기 때문에 CSS 파일에서 내가 원하는 부분을 찾기위해 시간을 쓰거나 길어진 CSS 파일을 쪼개서 관리할 필요가 없어졌습니다.

3.  CSS 파일을 작성하다보면 같은 종류의 요소에 같은 종류의 스타일 속성을 작성하게 되는 일이 종종 생기곤 하는데, Styled Components는 컴포넌트 단위로 스타일 속성을 작성하기 때문에 속성이 겹치는 일이 없었습니다.

<span style="color:#90caf9"><strong> 🤔 useRef가 필요한 상황을 예시를 들어 설명해 주세요. </strong></span>

useRef는 특정 요소의 DOM 주소값을 가져오는 React Hook입니다. React는 가상 DOM을 사용해서 SPA를 구현하기 때문에, DOM을 직접 조작하는 것은 React의 작동 방식과도 맞지 않고, 원하는 결과가 나오지 않을 수 있습니다. 

따라서, 예외의 상황이 아닌 경우는 DOM에 직접 접근해서는 안됩니다. DOM에 직접 접근해야하는 예외 상황들이 있는데, DOM 엘리먼트의 주소값을 활용해야 하는 경우로, 가장 대표적인 예시는 특정 요소에 포커스를 설정해야하는 상황이 있습니다.

이럴 때 useRef를 사용해서 DOM 주소 값을 받아와 사용할 수 있습니다.

#### ✔️ Redux

<span style="color:#90caf9"><strong> 🤔 상태관리 라이브러리의 필요성에 대해서 설명해 주세요. </strong></span>

Redux와 같은 상태관리 라이브러리는 전역 상태 저장소를 제공해줍니다. 기존의 React에서는 자식 컴포넌트에 props를 내려줘서 상태를 전달해줬습니다. 이 경우에는 해당 상태를 사용하지 않는 컴포넌트들도 오로지 상태를 전달해주기 위해서props를 받아야 했고, 이를 props drilling이라고 합니다.
상태 관리 라이브러리는 전역 상태 저장소를 제공해줌으로써 이 props drilling 문제를 해결해줍니다. 전역 상태 저장소가 있다면 props를 내려줄 필요없이 바로 이 저장소에 접근해서 필요한 상태를 가져다 사용하면 되기 때문입니다.

<span style="color:#90caf9"><strong> 🤔 Redux의 주요 개념들과 연결 관계를 설명해 주세요. </strong></span>

Redux의 주요 개념으로는 Action, Dispatch, Reducer, Store가 있으며, Action → Dispatch → Reducer → Store 순서로 데이터가 단방향으로 흐르게 됩니다.

Action은 어떤 액션을 취할 것인지 정의해 놓은 객체입니다. 해당 Action 객체가 어떤 동작을 하는지 명시해주는 type 속성을 가집니다.

Dispatch는 Reducer로 Action을 전달해주는 함수입니다. Dispatch의 전달인자로 Action 객체가 전달되며. Action 객체를 전달받은 Dispatch 함수는 Reducer를 호출합니다.

Reducer는 Dispatch에게서 전달받은 Action 객체의 type 값에 따라서 상태를 변경시키는 함수로, Reducer가 리턴하는 값이 새로운 상태가 됩니다. 이 때, Reducer는 순수함수여야 합니다. 외부 요인으로 인해 기대한 값이 아닌 엉뚱한 값으로 상태가 변경되는 일이 없어야하기 때문입니다.

Store는 Redux의 전역 저장소로, Redux 앱의 state가 저장되어 있는 오직 하나뿐인 저장소의 역할을 합니다.

---

### ✔️ HTTP/네트워크 , 웹 서버


<span style="color:#90caf9"><strong> 🤔 CSR과 SSR의 차이점에 대해서 설명해 주세요. </strong></span>

SSR과 CSR의 주요 차이점은 페이지가 렌더링되는 위치입니다. SSR은 서버에서 페이지를 렌더링하고, CSR은 브라우저(클라이언트)에서 페이지를 렌더링합니다. CSR은 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침하지 않고, 동적으로 라우팅을 관리합니다. SSR은 경로가 변경될 때마다 새로운 정적파일을 요청합니다.

<span style="color:#90caf9"><strong> 🤔 GET 메서드와 POST 메서드의 차이점에 대해 설명해 주세요. </strong></span>

GET 메서드는 존재하는 자원에 대한 요청을 위한 메서드, 즉 서버의 리소스를 조회하는 역할이고 POST 메서드는 새로운 자원을 생성하기 위한 메서드 즉, 서버의 리소스 변경을 위한 역할을 합니다.

<span style="color:#90caf9"><strong> 🤔 HTTP 메시지 구조에 대해 설명해 주세요. </strong></span>

 HTTP 메시지는 크게 start-line, header와 body로 나뉩니다. start-line은 어떤 프로토콜을 사용하는지, 어떤 HTTP 메서드인지, 상태 코드는 무엇인지 등 해당 요청 / 응답의 핵심 정보가 담겨있습니다.
header는 요청/응답에서 공통으로 자주 다루는 정보들이 담겨있습니다. 예를 들면 body의 Content-type이 무엇인지, 캐시의 유효 기간은 얼마나 되는지 등 공통으로 자주 주고받는 정보가 담겨있습니다. body는 해당 요청/ 응답에서 꼭 다뤄야 하는 중요한 정보를 담고 있습니다. 보통 추가/변경/삭제하고 싶은 리소스의 자세한 정보를 담기도 하고, 응답의 경우 요청자가 꼭 알아야하는 리소스에 대한 정보를 담게 됩니다.

<span style="color:#90caf9"><strong> 🤔 Same-Origin Policy와 CORS에 대해서 설명해 주세요. </strong></span>

 SOP는 Same Origin Policy의 줄임말로, 동일 출처 정책을 의미합니다. uri의 프로토콜, 호스트, 포트 이 3가지가 모두 동일해야 같은 출처(Same Origin)으로 인정하게 되는데요, 이 정책이 필요한 이유는 동일한 출처가 아닌 곳에서 요청이 오는 경우 해당 요청을 막아 높은 보안성을 유지하기 위함입니다. 대부분의 모던 브라우저에서는 이 정책을 기반으로 동일 출처로의 요청이 아니면 요청 자체를 막습니다. 크롬, Edge, Firefox와 같은 모던 웹 브라우저 사용을 권장하는 이유입니다.

다만, 서버에서 다른 출처에서의 요청을 허용하게 해줄 수 있는 CORS 설정을 해준 경우는 접근할 수 있습니다. 모든 출처로 부터의 요청을 허용할 수도 있고, 일부 출처로의 요청만 허용하는 것도 가능합니다. expressjs에서는 cors 미들웨어로 상황에 맞게 cors 설정을 제어할 수 있습니다.

<span style="color:#90caf9"><strong> 🤔 IP 프로토콜의 한계에 대해서 설명해 주세요. </strong></span>

IP 프로토콜은 두 사용자가 패킷 교환 방식으로 정보를 주고 받을 때 사용하는 통신 규약입니다. IP 프로토콜의 한계로는 비연결성, 비신뢰성이 있습니다. 인터넷 프로토콜(IP)는 패킷 단위로 통신하며, IP 패킷은 소포처럼 출발지 IP 주소, 목적지 IP 주소 정보를 포함하고 있습니다.

패킷은 한 번 전송되면 목적지에 도착할 때까지 인터넷 망의 수많은 노드를 지나게 되는데 
이 때, 패킷을 받을 대상이 없거나 서비스 불능 상태여도 클라이언트는 서버의 상태를 파악할 방법이 없기 때문에 패킷을 그대로 전송하게 됩니다. 이걸 비연결성이라고 합니다.

또한 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없습니다. 목적지에서도 패킷의 순서가 바뀌거나 소실된 상태로 도착할 수 있습니다. 이걸 비신뢰성이라고 합니다.

<span style="color:#90caf9"><strong> 🤔 HTTP 프로토콜의 특징에 대해 설명해 주세요. </strong></span>

HTTP는 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있으며, 무상태성, 비연결성이라는 특징을 갖습니다.

무상태성은 서버가 클라이언트의 상태를 기억하지 않는다는 뜻입니다. 즉, 상태 기억의 주체가 클라이언트가 된다는 말이며, 중간에 요청을 처리하는 서버가 바뀌어도 클라이언트가 상태를 잘 담아서 요청을 보내면 응답을 제대로 받을 수 있습니다. 서버가 바뀌어도 응답에 문제가 없다는 뜻은, 필요에 따라 서버를 무한히 증설할 수 있다는 뜻입니다.

비연결성은 요청과 응답을 주고받은 후에 서버와의 연결을 끊는 것을 의미합니다. 서버와의 연결을 지속하지 않고 필요할 때에만 연결하기 때문에 최소한의 자원만 사용하게 된다는 장점이 있습니다. 하지만 HTTP 1.0 버전은 여러 요청을 보내야 할 때에도 매 요청마다 서버 연결과 종료를 반복하는 비효율성이 발생한다는 한계가 있습니다. 이러한 한계점을 HTTP 1.1 버전에서는 지속 연결을 활용해서 해결합니다.

#### ✔️ 인증 / 보안

<span style="color:#90caf9"><strong> 🤔 Cookie의 MaxAge, Expires 옵션이 무엇인지, 설정하지 않으면 어떻게 되는지 설명해 주세요. </strong></span>

Cookie는 HTTP 프로토콜의 비상태성을 보완하기 위한 수단으로, 브라우저에 데이터를 저장할 때 사용합니다. Cookie의 MaxAge 옵션은 쿠키를 얼마나 유지할 것인지, Expires 옵션은 언제 폐기할 것인지 지정하는 옵션입니다. 두 옵션을 동시에 설정하면 MaxAge가 더 높은 우선 순위로 적용됩니다.

이 두 옵션중 하나라도 설정하지 않으면,해당 쿠키는 브라우저가 닫힐 때 폐기 됩니다. 따라서 쿠키를 빠르게 폐기하고 싶다면 옵션을 설정하지 않는 것이 좋고, 쿠키를 계속 사용하고 싶다면 두 옵션 중에 하나라도 설정해주는 것이 좋습니다.

이 때, 브라우저를 종료하면 삭제되는 임시 쿠키를 세션 쿠키(Session Cookie)라고 하고, 설정한 옵션만큼 사용가능한 쿠키를 영속성 쿠키(Persistent Cookie)라고 합니다.

---

### ✔️ 알고리즘

<span style="color:#90caf9"><strong> 🤔 재귀를 활용하기 좋은 상황은 언제인지 예시를 들어 설명해 주세요. </strong></span>

첫 번째는 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우입니다. 예시로는 피보나치 수열의 n번째 수를 구하는 문제가 있습니다. 피보나치 수열의 n번째 수는 n-1번째 수와 n-2번 째 수를 합한 값입니다. 몇 번째 수를 구하든 동일한 구조의 작은 문제로 나눌 수 있는 구조인 것입니다. 이런 상황에서 재귀를 활용하면 간결한 코드로 문제를 해결할 수 있습니다.

두 번째는 중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우입니다. 예시로는 객체를 문자열로 바꾸는 함수가 있습니다. 객체는 배열이나 객체도 담을 수 있으며, 얼마나 중첩되어 있을지 예측하기 어렵기 때문에 반복문을 사용하기에는 적합하지 않습니다. 이럴 때 재귀를 활용하면 가장 깊은 곳에 있는 배열이나 객체까지 확인할 수 있습니다. 

---

### ✔️ UI/UX , 웹 표준 & 웹 접근성

<span style="color:#90caf9"><strong> 🤔 UI, UX의 개념과 두 개념의 관계에 대해서 설명해 주세요. </strong></span>

UI는 사람들이 컴퓨터와 상호 작용하는 시스템 즉, UI는 보통 화면상의 그래픽 요소인 GUI를 의미합니다.

UX는 사용자가 어떤 시스템, 제품, 서비스를 직•간접적으로 이용하면서 느끼고 생각하는 총체적 경험을 의미합니다. 제품, 서비스 그 자체에 대한 경험은 물론, 홍보, 접근성, 사후 처리 등 직간접적으로 관련된 모든 경험을 사용자 경험이라고 할 수 있습니다.

UX는 UI를 포함합니다. 또한 좋은 UX가 좋은 UI를 의미하거나, 좋은 UI가 항상 좋은 UX를 보장하지는 않습니다. 하지만, 나쁜 UI는 보통 나쁜 UX를 유발합니다. 프론트엔드 개발자는 UI를 개선함으로써 UX를 개선할 수 있으며, UX가 좋지 않은 곳에서 UI 개선점을 찾아낼 수도 있습니다.

<span style="color:#90caf9"><strong> 🤔 Semantic HTML의 필요성을 예시를 들어 설명해 주세요. </strong></span>

HTML에는 많은 종류의 요소가 있지만, div와 span tag 두 가지 요소만 알아도 충분히 화면의 구조를 만들 수 있습니다. 하지만, 이 두 요소의 이름에는 의미가 없기 때문에 요소의 이름으로는 각 요소가 어떤 역할을 하는지 알 수 없습니다.

 header, main, nav, footer tag 등 시맨틱 요소를 사용하면 요소의 이름만 보고도 해당 요소가 어떤 역할을 하는지, 요소가 가진 의미를 통해 파악할 수 있게 됩니다.

시맨틱 HTML을 작성하면 요소의 이름만 봐도 의미를 파악할 수 있기 때문에 그만큼 의미를 전달하기 위한 시간과 id, class 작성에 필요한 시간 소모도 줄어들고 개발자간 소통이 원활해집니다.

검색 엔진은 HTML 코드를 보고 문서의 구조를 파악하기 때문에 시맨틱 요소를 사용함으로써 HTML에 의미를 부여하는 것만으로도 검색 효율성을 높일 수 있습니다.

마지막으로 시맨틱 요소를 사용하면 화면의 구조를 짜는 것을 넘어 구조에 대한 정보를 전달할 수 있어 요소에 담긴 콘텐츠도 더 명확하게 전달할 수 있으므로 웹 접근성을 향상시킬 수 있습니다