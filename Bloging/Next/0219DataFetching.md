# 📚 데이터 페치

### 🤔 데이터 페치

```tsx
export default async function Page() {
  const data = await fetch('url');
  const res = await data.json();

  return <div>{res.title}</div>;
}
```

페이지가 사전 렌더링 되는 것을 방지하려면 `export const dynamic = 'force-dynamic'`을 설정합니다. 그러나 일반적으로 `cookies`, `headers` 또는 페이지 props에서 들어오는 것을 읽는 것과 같은 함수를 사용하게 되는데 `searchParams`는 자동으로 페이지를 동적으로 렌더링합니다. 이 경우에는 force-dynamic 설정을 사용하지 않아도 됩니다.

### 🤔 패턴

#### 1. 병렬 및 순차적 데이터 페칭

- 순차적 데이터 페칭

  컴포넌트 트리의 요청은 서로 종속적이며, 이로 인해 로딩 시간이 길어질 수 있습니다. 중첩된 구성 요소가 있고 각 요소가 고유한 데이터를 가져오는 경우, 해당 데이터 요청이 메모화 되지 않으면 데이터는 순차적으로 로드됩니다.

  `loading.tsx`나 `suspense`를 사용하여 React가 결과를 스트리밍하는 동안 즉시 로딩 상태를 표시할 수 있습니다. 이를 통해 데이터 요청으로 인한 전체 경로 차단을 방지할 수 있으며, 사용자는 페이지의 준비 된 부분과 상호 작용할 수 있습니다.

- 병렬적 데이터 페칭

  경로의 요청은 동시에 이루어지며, 동시에 데이터를 로드합니다. 이렇게 하면 데이터를 더 빠르게 로드할 수 있습니다. 기본적으로 레이아웃 및 페이지는 병렬로 렌더링 됩니다. `async/await`과 같은 대기 중인 요청은 그 아래의 모든 요청을 차단합니다.

  데이터를 병렬로 페치하려면 데이터를 사용하는 구성 요소 외부에서 정의하여 요청을 병렬로 시작할 수 있습니다. 이렇게 하면 두 요청을 동시에 시작하여 시간을 절약할 수 있지만 사용자는 두 요청이 모두 해결 될 때까지 데이터를 볼 수 없습니다.

### 🤔 데이터 사전 로딩

cache함수, preload패턴, 패키지를 결합하여 server-only앱 전체에서 사용할 수 있는 데이터 가져오기 유틸리티를 만들 수 있습니다.

```tsx
import { cache } from 'react';
import 'server-only';

export const preload = (id: string) => {
  void getItem(id);
};

export const getItem = cache(async (id: string) => {
  // ...
});
```

이 방식을 사용하면 데이터를 적극적으로 가져오고, 응답을 캐시하고, 데이터를 가져오는 과정을 서버에서만 수행되도록 보장할 수 있습니다. 레이아웃, 페이지 또는 컴포넌트에서 내보내기를 사용하여 항목의 데이터를 가져오는 시기를 제어할 수 있습니다.

---

# 📚 데이터 캐싱

### 🤔 캐싱하기

Next.js는 렌더링 작업과 데이터 요청을 캐싱하여 애플리케이션의 성능을 개선하고 비용을 절감합니다. 캐싱 동작은 경로가 정적으로 렌더링되는지 동적으로 렌더링되는지, 데이터가 캐시되는지 캐시되지 않는지, 요청이 초기 방문의 일부인지 후속 탐색의 일부인지에 따라 달라집니다. 사용 사례에 따라 개별 경로 및 데이터 요청에 대한 캐싱 동작을 구성할 수 있습니다.

### 🤔 메모 요청

Next.js는 동일한 URL과 옵션이 있는 요청을 자동으로 메모하기 위해 fetch API를 확장하며, React 구성 요소 트리의 여러 곳에서 동일한 데이터에 대한 패치 함수를 호출하면서도 한번만 실행할 수 있습니다.

예를 들어, 경로 전체에서 동일한 데이터를 사용해야 하는 경우 (레이아웃, 페이지 및 컴포넌트) 네트워크에서 동일한 데이터에 대한 여러 요청을 하는 것의 성능 영향에 대해 걱정하지 않고 필요한 구성 요소에서 데이터를 페치할 수 있습니다.

```tsx
async function getItem(id: string) {
  const res = await fetch(`url${id}`);
  return res.json();
}

const item = getItem();
const item2 = getItem();

// 경로를 렌더링하는 동안 특정 요청이 처음 호출되면 결과는 메모리에 저장되지 않고 캐시에 저장
// 해당 함수가 실행되고, 외부 소스에서 데이터를 가져오고 결과가 메모리에 저장됨
// 동일한 요청에 대한 후속 함수 호출은 캐시가 되고, 메모리에서 데이터 반환
// 경로가 렌더링되고 메모리가 재설정 되면 모든 요청 메모 항목이 지워짐
```

- duration

  캐시는 React 구성 요소 트리가 렌더링을 완료할 때까지 서버 요청의 수명 동안 지속

- revalidating

  메모이제이션은 서버 요청 전체에서 공유되지 않고 렌더링 중에만 적용되므로, 다시 검증할 필요 x

- Optioning out

  GET메모이제이션은 요청 의 메서드 에만 적용되고 다른 메서드는 메모이제이션되지 않습니다. 이 기본 동작은 React 최적화이며, 이를 옵트아웃하는 것을 권장하지 않습니다.

  개별 요청을 관리하려면 `signal` 옵션을 사용합니다.
