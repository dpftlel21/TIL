# 1. Token !

### ✔️ 해싱 (Hashing)

복호화가 가능한 다른 암호화 방식들과 달리, 해싱은 암호화만 가능합니다. 해싱은 해시 함수를 이용하여 암호화를 진행합니다.

#### 😀 해시 함수 특징

- 항상 같은 길이 문자열 리턴

- 서로 다른 문자열에 동일한 해시 함수를 사용하면 반드시 다른 결과값 도출

- 동일한 문자열에 동일한 해시 함수를 사용하면 항상 같은 결과값 도출

#### 😀 레인보우 테이블, 솔트(Salt)

<img src = "https://postfiles.pstatic.net/MjAyMzA3MDNfMTYw/MDAxNjg4MzUwNjU3NzU2.U1MLMeT-Au978sRnlhtpc9inf2QmDb9g_mKjmxYsZbgg.t1Fel95euSgxRaUgaNV9Po8r8j98m5Vf_-MWox8PR44g.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-03_111704.png?type=w773" width = 400>

항상 같은 결과값이 나온다는 특성을 이용해 해시 함수를 거치기 이전의 값을 알아낼 수 있도록 기록해 놓은 표인 레인보우 테이블이 존재합니다. 레인보우 테이블에 기록된 값의 경우에는 유출이 되었을 때 해싱을 했더라도 해싱 이전의 값을 알아낼 수 있으므로 보안상 위협이 될 수 있습니다.

이때 활용하는 것이 솔트(Salt) 입니다. 마치 소금을 치듯 해싱 이전 값에 임의의 값을 더해 데이터가 유출되더라도 해싱 이전의 값을 알아내기 더욱 어렵게 만드는 방법을 의미합니다.

솔트를 사용하게 되면 해싱 값이 유출되더라도, 솔트가 함께 유출된 것이 아니라면 암호화 이전의 값을 알아내는 것은 불가능에 가깝습니다.

#### 🤔 해싱의 목적

해싱의 목적은 데이터 그 자체를 사용하는 것이 아니라, 동일한 값의 데이터를 사용하고 있는지에 대한 여부만 확인하는 것이 목적이기 때문에 복호화가 불가능한 암호화 방식을 사용합니다.

해싱은 민감한 데이터를 다루어야 하는 상황에서 데이터 유출의 위험성은 줄이면서 데이터의 유효성을 검증하기 위해서 사용되는 단방향 암호화 방식입니다.

---

### ✔️ Token

개발자들은 서버의 부담을 줄이기 위해 서버가 사용자의 인증 상태를 저장하는 것이 아닌 클라이언트에 이를 저장하는 방법을 고민하게 되었고, 그 결과 토큰 기반 인증 방식이 등장하였습니다.

토큰 기반 인증은 유저의 인증 상태를 클라이언트에 저장할 수 있어서, 세션 인증 방식과 비교해 서버의 부하나 메모리 부족 문제를 줄일 수 있습니다.

토큰은 교통 승차권과 같이 무언가를 이용할 수 있는 권한이나 자격을 나타내는 증표입니다. 웹 보안에서의 토큰은 인증과 권한 정보를 담고 있는 암호화된 문자열을 말합니다. 이를 이용해 특정 애플리케이션에 대한 사용자의 접근 권한을 부여할 수 있습니다.

#### 😀 토큰 인증 방식의 흐름

<img src ="https://postfiles.pstatic.net/MjAyMzA3MDNfMzMg/MDAxNjg4MzYzNDE3NDgz.Ly81_DAjJyjPWOKg_IyUpseiGX2P1jzbJF20IZV2Dowg.yO2c2hgezv0Fst5E7RjN-kyxFwl_0dqOji1TbMSJhKQg.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-03_144936.png?type=w773" width = 400>

토큰의 인증 방식은 다음과 같은 순서로 흐릅니다.

1. 사용자가 인증 정보를 담아 서버에 로그인 요청을 보냄

2. 서버는 데이터베이스에 저장된 사용자 인증 정보 확인

3. 인증 성공 → 해당 사용자 인증 및 권한 정보를 서버의 비밀 키와 함께 토큰으로 암호화

4. 토큰을 클라이언트에 전달

   - HTTP 상에서 인증 토큰을 보내기 위해 사용하는 헤더인 Authorization 헤더를 사용하거나, 쿠키로 전달하는 등의 방법을 사용

5. 클라이언트는 받은 토큰을 저장

   - 저장하는 위치는 Local Storage, Session Storage, Cookie 등,,

6. 클라이언트가 서버로 리소스를 요청할 때 토큰을 함께 전달

   - 토큰을 보낼 때에 Authorization 헤더를 사용하거나 쿠키로 전달 0

7. 서버는 전달받은 토큰을 서버의 비밀 키를 통해 검증, 이를 통해 토큰이 위조되었는지 혹은 토큰의 유효 기간이 지나지 않았는지 등을 확인 0

8. 토큰이 유효하다면 클라이언트의 요청에 대한 응답 데이터를 전송

#### 😀 토큰 인증 방식의 장점

- 무상태성 : 서버가 유저의 인증 상태를 관리하지 않으며, 서버는 비밀 키를 통해 클라이언트에서 보낸 토큰의 유효성만 검증하면 되기 때문에 무상태적인 아키텍처 구축 0

- 확장성 : 다수의 서버가 공통된 세션 데이터를 가질 필요가 없으며, 이를 통해 서버 확장이 더 용이

- 어디서나 토큰 생성 0 : 토큰의 생성, 검증이 하나의 서버에서 이루어지지 않아도 되기 때문에 토큰 생성만을 담당하는 서버를 구축 o 이를 통해 여러 서비스 간 공통 인증 서버 구현 o

- 권한 부여 용이 : 토큰은 인증 상태, 접근 권한 등 다양한 정보를 담을 수 있기 때문에 사용자 권한 부여에 용이, 이를 활용해 어드민 권한 부여 및 정보에 접근할 수 있는 범위도 설정 o

#### 😀 JWT (JSON WEB TOKEN)

토큰 기반 인증 구현 시 대표적으로 사용하는 기술로 JWT(JSON Web Token)가 있습니다. JWT는 JSON 객체에 정보를 담고 이를 토큰으로 암호화하여 전송할 수 있는 기술입니다. 클라이언트가 서버에 요청을 보낼 때, 인증정보를 암호화된 JWT 토큰으로 제공하고, 서버는 이 토큰을 검증하여 인증정보를 확인할 수 있습니다.

JWT의 구성은 다음과 같습니다.

<img src = "https://postfiles.pstatic.net/MjAyMzA3MDNfNjYg/MDAxNjg4MzY0MjYwODY3.s-VF-gqEPYxLOFznhpif-QZ-2x7mjvCpeCsimLNUqMsg.7l4VFWMHJ4YwMK76m-vdVkkjbgDlW2p89Geo9HBpNF0g.PNG.dkdnmju/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-07-03_150409.png?type=w773" width = 400>

<span style="color:#90caf9"><strong> 1. Header </strong></span>

```js
{
    "alg" : "HS256",
    "typ" : "JWT",
}
```

Header에는 마치 HTTP의 헤더처럼 해당 토큰 자체를 설명하는 데이터가 담겨 있습니다. 토큰의 종류, 그리고 시그니처를 만들 때 사용할 알고리즘을 JSON 형태로 작성합니다.

<span style="color:#90caf9"><strong> 2. Payload </strong></span>

Payload는 HTTP의 페이로드와 마찬가지로 전달하려는 내용물을 담고 있는 부분입니다. 어떤 정보에 접근 가능한지에 대한 권한, 유저의 이름과 같은 개인정보, 토큰의 발급 시간 및 만료 시간 등의 정보들을 JSON 형태로 담습니다.

```js
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```

<span style="color:#90caf9"><strong> 3. Signature </strong></span>

Signature는 토큰의 무결성을 확인할 수 있는 부분입니다. Header와 Payload가 완성되었다면, Signature는 이를 서버의 비밀 키(암호화에 추가할 salt)와 Header에서 지정한 알고리즘을 사용하여 해싱합니다.

따라서 누군가 권한을 속이기 위해 토큰의 Payload를 변조하는 등의 시도를 하더라도 토큰을 발급할 때 사용한 Secret을 정확하게 알고 있지 못한다면 유효한 Signature를 만들어낼 수 없기 때문에 서버는 Signature를 검증하는 단계에서 올바르지 않은 토큰임을 알아낼 수 있습니다.

#### 😱 토큰 인증 방식의 한계

- 무상태성 : 인증 상태를 관리하는 주체가 서버가 아니므로, 토큰이 탈취되어도 해당 토큰을 강제로 만료시킬 수 없습니다. 따라서 토큰이 만료될 때까지 사용자로 가장해 계속해서 요청을 보낼 수 있습니다.

- 유효기간 : 토토큰이 탈취되는 상황을 대비해서 유효 기간을 짧게 설정하면, 사용자는 토큰이 만료될 때마다 다시 로그인을 진행해야 하기 때문에 좋지 않은 사용자 경험을 제공합니다. 그렇다고 유효 기간을 길게 설정하면 토큰이 탈취될 경우 더 치명적으로 작용할 수 있습니다.

- 토큰의 크기 : 토큰에 여러 정보를 담을 수 있는 만큼, 많은 데이터를 담으면 그만큼 암호화하는 과정도 길어지고 토큰의 크기도 커지기 때문에 네트워크 비용 문제가 생길 수 있습니다.

#### 😀 엑세스 토큰(Access)과 리프레시 토큰(Refresh Token)

<span style="color:#90caf9"><strong> - 엑세스 토큰(Access Token) </strong></span>

서버에 접근하기 위한 토큰으로 보안을 위해 24시간정도의 짧은 유효기간이 설정되어 있습니다.

<span style="color:#90caf9"><strong> - 리프레시 토큰(Refresh Token) </strong></span>

엑세스 토큰이 만료되었을 때 새로운 엑세스 토큰을 발급받기 위해 사용되는 토큰입니다. 따라서 엑세스 토큰보다 더 긴 유효기간을 설정합니다.

이렇게 두 가지의 각기 다른 토큰을 사용하는 경우, 액세스 토큰이 만료되더라도 리프레시 토큰의 유효기간이 남아있다면 사용자는 다시 로그인을 할 필요 없이 지속해서 인증 상태를 유지할 수 있습니다.